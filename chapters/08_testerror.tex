\chapter{Testing and Error Handling}\label{testerror}

Novices write code and pray that it works.
Experienced programmers know that prayer alone is never enough,
and take steps to protect whatever sanity they have left.
This chapter looks at the tools R gives us for doing this.

\section{How does R handle errors?}

Python programs handle errors
by \gref{g:raise-exception}{raising} and \gref{g:catch-exception}{catching} \gref{g:exception}{exceptions}:

\begin{lstlisting}
values = [-1, 0, 1]
for i in range(4):
    try:
        reciprocal = 1/values[i]
        print("index {} value {} reciprocal {}".format(i, values[i], reciprocal))
    except ZeroDivisionError:
        print("index {} value {} ZeroDivisionError".format(i, values[i]))
    except Exception as e:
        print("index{} some other Exception: {}".format(i, e))
\end{lstlisting}

\begin{lstlisting}
index 0 value -1 reciprocal -1.0
index 1 value 0 ZeroDivisionError
index 2 value 1 reciprocal 1.0
index3 some other Exception: list index out of range
\end{lstlisting}

R draws on a different tradition.
We say that the operation \gref{g:signal-condition}{signals} a \gref{g:condition}{condition}
that some other piece of code then \gref{g:handle-condition}{handles}.
These things are all simpler to do using the \texttt{rlang} library,
so we begin by loading that:

\begin{lstlisting}
library(rlang)
\end{lstlisting}

In order of increasing severity,
the three built-in kinds of conditions are \gref{g:message}{messages},
\gref{g:warning}{warnings},
and \gref{g:error}{errors}.
(There are also interrupts,
which are generated by the user pressing Control-C to stop an operation,
but we will ignore those for the sake of brevity.)
We can signal conditions using the functions \texttt{message}, \texttt{warning}, and \texttt{stop},
each of which takes an error message as a parameter:

\begin{lstlisting}
message("This is a message.")
\end{lstlisting}

\begin{lstlisting}
This is a message.
\end{lstlisting}

\begin{lstlisting}
warning("This is a warning.\n")
\end{lstlisting}

\begin{lstlisting}
Warning: This is a warning.
\end{lstlisting}

\begin{lstlisting}
stop("This is an error.")
\end{lstlisting}

\begin{lstlisting}
Error: This is an error.
\end{lstlisting}

Note that we have to supply our own line ending for warnings
but not for the other two cases.
Note also that there are very few situations in which a warning is appropriate:
if something has truly gone wrong then we should stop,
but otherwise we should not distract users from more pressing concerns.

The bluntest of instruments for handling errors is to ignore them.
If a statement is wrapped in the function \texttt{try}
then errors that occur in it are still reported,
but execution continues.
Compare this:

\begin{lstlisting}
attemptWithoutTry <- function(left, right){
  temp <- left + right
  "result" # returned
}
result <- attemptWithoutTry(1, "two")
\end{lstlisting}

\begin{lstlisting}
Error in left + right: non-numeric argument to binary operator
\end{lstlisting}

\noindent
with this:

\begin{lstlisting}
attemptUsingTry <- function(left, right){
  temp <- try(left + right)
  "value returned" # returned
}
result <- attemptUsingTry(1, "two")
\end{lstlisting}

\begin{lstlisting}
Error in left + right : non-numeric argument to binary operator
\end{lstlisting}

\begin{lstlisting}
cat("result is", result)
\end{lstlisting}

\begin{lstlisting}
result is value returned
\end{lstlisting}

We can suppress error messages inside \texttt{try}
by setting \texttt{silent} to \texttt{TRUE}:

\begin{lstlisting}
attemptUsingTryQuietly <- function(left, right){
  temp <- try(left + right, silent = TRUE)
  "result" # returned
}
result <- attemptUsingTryQuietly(1, "two")
cat("result is", result)
\end{lstlisting}

\begin{lstlisting}
result is result
\end{lstlisting}

\noindent
Do not do this,
lest you one day find yourself wandering a trackless hellscape
searching for error messages that your younger and more na\"{i}ve self deliberately suppressed.

If we want to handle conditions rather than ignore them,
we can use \texttt{tryCatch}.
Our error-handling function can be as simple or as complex as we want;
in the example below,
it simply shows the object containing information about the error:

\begin{lstlisting}
tryCatch(
  attemptWithoutTry(1, "two"),
  error = function(cnd) print(glue("error object is {cnd}"))
)
\end{lstlisting}

\begin{lstlisting}
error object is Error in left + right: non-numeric argument to binary operator
\end{lstlisting}

\noindent
We can also handle non-fatal errors using \texttt{withCallingHandlers},
and define new types of conditions,
but this is done less often in day-to-day R code than in Python:
see \emph{\href{http://adv-r.had.co.nz/}{Advanced R}}
or \href{https://www.onceupondata.com/2018/09/28/handling-r-errors/}{this tutorial}
for details.

\section{What should we know about testing in general?}

In keeping with common programming practice,
we have left testing until the last possible moment.
The standard testing library for R is \href{https://github.com/r-lib/testthat}{testthat},
which shares many features with Python's \href{https://docs.python.org/3/library/unittest.html}{unittest}
and other \gref{g:unit-test}{unit testing} libraries:

\begin{enumerate}
\item
  Each test consists of a single function
  that tests a single property or behavior of the system.
\item
  Tests are collected into files with predictable names
  so that they can be found by a \gref{g:test-runner}{test runner}.
\item
  Shared \gref{g:testing-setup}{setup} and \gref{g:testing-teardown}{teardown} steps
  are put in functions of their own.
\end{enumerate}

Let's load the library and write our first test:

\begin{lstlisting}
library(testthat)
\end{lstlisting}

\begin{lstlisting}
Attaching package: 'testthat'

The following objects are masked from 'package:rlang':
    is_false, is_null, is_true

The following object is masked from 'package:dplyr':
    matches

The following object is masked from 'package:purrr':
    is_null

The following object is masked from 'package:tidyr':
    matches
\end{lstlisting}

\begin{lstlisting}
test_that("Zero equals itself", {expect_equal(0, 0)})
\end{lstlisting}

As is conventional with unit testing libraries,
no news is good news:
if a test passes,
it doesn't produce output because it doesn't need our attention.
Let's try something that ought to fail:

\begin{lstlisting}
test_that("Zero equals one", {expect_equal(0, 1)})
\end{lstlisting}

\begin{lstlisting}
Error: Test failed: 'Zero equals one'
* 0 not equal to 1.
1/1 mismatches
[1] 0 - 1 == -1
\end{lstlisting}

Good:
we can draw some comfort from the fact that Those Beyond have not yet changed the fundamental rules of arithmetic.
But what are the curly braces around \texttt{expect\_equal} for?
The answer is that they create a \gref{g:code-block}{code block} for \texttt{test\_that} to run.
We can run \texttt{expect\_equal} on its own:

\begin{lstlisting}
expect_equal(0, 1)
\end{lstlisting}

\begin{lstlisting}
Error: 0 not equal to 1.
1/1 mismatches
[1] 0 - 1 == -1
\end{lstlisting}

\noindent
but that doesn't produce a summary of how many tests passed or failed.
Passing a code block to \texttt{test\_that} also allows us to check several things in one test:

\begin{lstlisting}
test_that("Testing two things", {
  expect_equal(0, 0)
  expect_equal(0, 1)
})
\end{lstlisting}

\begin{lstlisting}
Error: Test failed: 'Testing two things'
* 0 not equal to 1.
1/1 mismatches
[1] 0 - 1 == -1
\end{lstlisting}

A code block is a way to pass around multiple expressions.
It is not the same thing as an \gref{g:anonymous-function}{anonymous function},
which is why running the test below doesn't actually check anything:

\begin{lstlisting}
test_that("Using an anonymous function", function() {
  print("In our anonymous function")
  expect_equal(0, 1)
})
\end{lstlisting}

\section{How should we organize our tests?}\label{testerror-organize}

Running blocks of tests by hand is a bad practice.
Instead,
we should put related tests in files
and put those files in a directory called \texttt{tests/testthat}
so that we can run some or all of those tests with a single command.
To start,
let's create \texttt{tests/testthat/test\_example.R}:

\begin{lstlisting}
library(testthat)
context("Demonstrating the testing library")

test_that("Testing a number with itself", {
  expect_equal(0, 0)
  expect_equal(-1, -1)
  expect_equal(Inf, Inf)
})

test_that("Testing different numbers", {
  expect_equal(0, 1)
})

test_that("Testing with a tolerance", {
  expect_equal(0, 0.01, tolerance = 0.05, scale = 1)
  expect_equal(0, 0.01, tolerance = 0.005, scale = 1)
})
\end{lstlisting}

The first line loads the \texttt{testthat} package,
which gives us our tools.
The call to \texttt{context} on the second line gives this set of tests a name for reporting purposes.
After that,
we add as many calls to \texttt{test\_that} as we want,
each with a name and a code block.
We can now run this file from within RStudio:

\begin{lstlisting}
test_dir("tests/testthat")
\end{lstlisting}

\begin{lstlisting}
v |  OK F W S | Context

/ |   0       | Skipping rows correctly
\ |   0 2     | Skipping rows correctly
x |   0 5     | Skipping rows correctly [0.1 s]
---------------------------------------------------------------------------
test_determine_skip_rows_a.R:9: failure: The right row is found when there are header rows
`result` not equal to 2.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:14: failure: The right row is found when there are header rows and blank lines
`result` not equal to 3.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:19: failure: The right row is found when there are no header rows to discard
`result` not equal to 0.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:23: failure: No row is found when 'iso3' isn't present
`determine_skip_rows("a1,a2\nb1,b1\n")` did not throw an error.

test_determine_skip_rows_a.R:28: failure: No row is found when 'iso3' is in the wrong place
`determine_skip_rows("stuff,iso3\n")` did not throw an error.
---------------------------------------------------------------------------

/ |   0       | Skipping rows correctly
v |   5       | Skipping rows correctly

/ |   0       | Demonstrating the testing library
x |   4 2     | Demonstrating the testing library
---------------------------------------------------------------------------
test_example.R:11: failure: Testing different numbers
0 not equal to 1.
1/1 mismatches
[1] 0 - 1 == -1

test_example.R:16: failure: Testing with a tolerance
0 not equal to 0.01.
1/1 mismatches
[1] 0 - 0.01 == -0.01
---------------------------------------------------------------------------

/ |   0       | Finding empty rows
x |   1 2     | Finding empty rows
---------------------------------------------------------------------------
test_find_empty_a.R:9: failure: A single non-empty row is not mistakenly detected
`result` not equal to NULL.
Types not compatible: integer is not NULL

test_find_empty_a.R:14: failure: Half-empty rows are not mistakenly detected
`result` not equal to NULL.
Types not compatible: integer is not NULL
---------------------------------------------------------------------------

/ |   0       | Finding empty rows
v |   3       | Finding empty rows

/ |   0       | Testing properties of tibbles
v |   1   1   | Testing properties of tibbles
---------------------------------------------------------------------------
test_tibble.R:6: warning: Tibble columns are given the name 'value'
`as.tibble()` is deprecated, use `as_tibble()` (but mind the new semantics).
This warning is displayed once per session.
---------------------------------------------------------------------------

== Results ================================================================
Duration: 0.4 s

OK:       14
Failed:   9
Warnings: 1
Skipped:  0
\end{lstlisting}

\noindent
Care is needed when interpreting this summary:
there are four \texttt{test\_that} calls,
but eight actual checks,
and the number of successes and failures is counted by recording the latter,
not the former.

Let's create another file called \texttt{tests/testthat/test\_tibble.R}
to see how we might write more interesting tests:

\begin{lstlisting}
library(tidyverse)
library(testthat)
context("Testing properties of tibbles")

test_that("Tibble columns are given the name 'value'", {
  t <- c(TRUE, FALSE) %>% as.tibble()
  expect_equal(names(t), "value")
})
\end{lstlisting}

\noindent
(We don't actually have to call our test files \texttt{test\_something.R},
but \texttt{test\_dir} and the rest of R's testing infrastructure expect us to.
Similarly,
we don't have to put them in a \texttt{tests} directory,
but gibbering incoherence will ensue if we do not.)
Now let's run all of our tests:

\begin{lstlisting}
test_dir("tests/testthat")
\end{lstlisting}

\begin{lstlisting}
v |  OK F W S | Context

/ |   0       | Skipping rows correctly
x |   0 5     | Skipping rows correctly
---------------------------------------------------------------------------
test_determine_skip_rows_a.R:9: failure: The right row is found when there are header rows
`result` not equal to 2.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:14: failure: The right row is found when there are header rows and blank lines
`result` not equal to 3.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:19: failure: The right row is found when there are no header rows to discard
`result` not equal to 0.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:23: failure: No row is found when 'iso3' isn't present
`determine_skip_rows("a1,a2\nb1,b1\n")` did not throw an error.

test_determine_skip_rows_a.R:28: failure: No row is found when 'iso3' is in the wrong place
`determine_skip_rows("stuff,iso3\n")` did not throw an error.
---------------------------------------------------------------------------

/ |   0       | Skipping rows correctly
v |   5       | Skipping rows correctly

/ |   0       | Demonstrating the testing library
x |   4 2     | Demonstrating the testing library
---------------------------------------------------------------------------
test_example.R:11: failure: Testing different numbers
0 not equal to 1.
1/1 mismatches
[1] 0 - 1 == -1

test_example.R:16: failure: Testing with a tolerance
0 not equal to 0.01.
1/1 mismatches
[1] 0 - 0.01 == -0.01
---------------------------------------------------------------------------

/ |   0       | Finding empty rows
x |   1 2     | Finding empty rows
---------------------------------------------------------------------------
test_find_empty_a.R:9: failure: A single non-empty row is not mistakenly detected
`result` not equal to NULL.
Types not compatible: integer is not NULL

test_find_empty_a.R:14: failure: Half-empty rows are not mistakenly detected
`result` not equal to NULL.
Types not compatible: integer is not NULL
---------------------------------------------------------------------------

/ |   0       | Finding empty rows
v |   3       | Finding empty rows

/ |   0       | Testing properties of tibbles
v |   1       | Testing properties of tibbles

== Results ================================================================
Duration: 0.2 s

OK:       14
Failed:   9
Warnings: 0
Skipped:  0
\end{lstlisting}

\noindent
That's rather a lot of output.
Happily,
we can provide a \texttt{filter} argument to \texttt{test\_dir}:

\begin{lstlisting}
test_dir("tests/testthat", filter = "test_tibble.R")
\end{lstlisting}

\begin{lstlisting}
Error in test_files(paths, reporter = reporter, env = env, stop_on_failure = stop_on_failure, : No matching test file in dir
\end{lstlisting}

\noindent
Ah:
it turns out that \texttt{filter} is applied to filenames
\emph{after} the leading \texttt{test\_} and the trailing \texttt{.R} have been removed.
Let's try again:

\begin{lstlisting}
test_dir("tests/testthat", filter = "tibble")
\end{lstlisting}

\begin{lstlisting}
v |  OK F W S | Context

/ |   0       | Testing properties of tibbles
v |   1       | Testing properties of tibbles

== Results ================================================================
OK:       1
Failed:   0
Warnings: 0
Skipped:  0
\end{lstlisting}

\noindent
That's better,
and it illustrates our earlier point about the need to follow conventions.

\section{How can we write a few simple tests?}\label{testerror-simple}

To give ourselves something more interesting to test,
let's create a file called \texttt{scripts/find\_empty\_01.R}
containing a single function \texttt{find\_empty\_rows} to identy all the empty rows in a CSV file.
Our first implementation is:

\begin{lstlisting}
find_empty_rows <- function(source) {
  data <- read_csv(source)
  empty <- data %>%
    pmap(function(...) {
      args <- list(...)
      all(is.na(args) | (args == ""))
    })
  data %>%
    transmute(id = row_number()) %>%
    filter(as.logical(empty)) %>%
    pull(id)
}
\end{lstlisting}

\noindent
This is complex enough to merit line-by-line exegesis:

\begin{enumerate}
\item
  Define the function with one argument \texttt{source}, whence we shall read.
\item
  Read tabular data from that source and assign the resulting tibble to \texttt{data}.
\item
  Begin a pipeline that will assign something to the variable \texttt{empty}.

  \begin{enumerate}
    \item
    Use \texttt{pmap} to map a function across each row of the tibble.
    Since we don't know how many columns are in each row,
    we use \texttt{...} to take any number of arguments.
  \item
    Convert the variable number of arguments to a list.
  \item
    Check to see if all of those arguments are either \texttt{NA} or the empty string.
  \item
    Close the mapped function's definition.
  \end{enumerate}
\item
  Start another pipeline.
  Its result isn't assigned to a variable,
  so whatever it produces will be the value returned by \texttt{find\_empty\_rows}.

  \begin{enumerate}
    \item
    Construct a tibble that contains only the row numbers of the original table in a column called \texttt{id}.
  \item
    Filter those row numbers to keep only those corresponding to rows that were entirely empty.
    The \texttt{as.logical} call inside \texttt{filter} is needed because the value returned by \texttt{pmap}
    (which we stored in \texttt{empty})
    is a list, not a logical vector.
  \item
    Use \texttt{pull} to get the one column we want from the filtered tibble as a vector.
  \end{enumerate}
\end{enumerate}

There is a lot going on here,
particularly if you are new to R\footnote{As we were at the time of writing.}
and don't know that \texttt{pmap} is the function this problem wants.
But now that we have it,
we can do this:

\begin{lstlisting}
source("scripts/find_empty_01.R")
find_empty_rows("a,b\n1,2\n,\n5,6")
\end{lstlisting}

The \texttt{source} function reads R code from the given source.
Using this inside an R~Markdown file is usually a bad idea,
since the generated HTML or PDF won't show readers what code we loaded and ran.
On the other hand,
if we are creating command-line tools for use on clusters or in other batch processing modes,
and are careful to display the code in a nearby block,
the stain on our soul is excusable.

The more interesting part of this example is the call to \texttt{find\_empty\_rows}.
Instead of giving it the name of a file,
we have given it the text of the CSV we want parsed.
This string is passed to \texttt{read\_csv},
which (according to documentation that only took us 15 minutes to realize we had already seen)
interprets its first argument as a filename \emph{or}
as the actual text to be parsed if it contains a newline character.
This allows us to write put the \gref{g:test-fixture}{test fixture}
right there in the code as a literal string,
which experience shows is to understand and maintain
than having test data in separate files.

Our function seems to work,
but we can make it more pipelinesque:

\begin{lstlisting}
find_empty_rows <- function(source) {
  read_csv(source) %>%
    pmap_lgl(function(...) {
      args <- list(...)
      all(is.na(args) | (args == ""))
    }) %>%
    tibble(empty = .) %>%
    mutate(id = row_number()) %>%
    filter(empty) %>%
    pull(id)
}
\end{lstlisting}

\noindent
Going line by line once again:

\begin{enumerate}
\item
  Define a function with one argument called \texttt{source}, from which we shall once again read.
\item
  Read from that source to fill the pipeline.
\item
  Map our test for emptiness across each row, returning a logical vector as a result.
  (\texttt{pmap\_lgl} is a derivative of \texttt{pmap} that always casts its result to logical.
  Similar functions like \texttt{pmap\_dbl} return vectors of other types;
  and many other tidyverse functions also have strongly-typed variants.)
\item
  Turn that logical vector into a single-column tibble,
  giving that column the name ``empty''.
  We explain the use of \texttt{.} below.
\item
  Add a second column with row numbers.
\item
  Discard rows that aren't empty.
\item
  Return a vector of the remaining row IDs.
\end{enumerate}

\begin{quote}
\textbf{Wat?}

Buried in the middle of the pipe shown above is the expression:

\begin{lstlisting}
    tibble(empty = .)
\end{lstlisting}

\noindent
Quoting from \emph{\href{http://adv-r.had.co.nz/}{Advanced R}},
``The function arguments look a little quirky
but allow you to refer to \texttt{.} for one argument functions,
\texttt{.x} and \texttt{.y.} for two argument functions,
and \texttt{..1}, \texttt{..2}, \texttt{..3}, etc, for functions with an arbitrary number of arguments.''
In other words,
\texttt{.} in tidyverse functions usually means
``whatever is on the left side of the \texttt{\pipe} operator
that would normally be passed as the function's first argument.''
Without this,
we have no easy way to give the sole column of our newly-constructed tibble a name.
(See also the discussion in Section~\ref{debt-functional}.)
\end{quote}

Here's the first batch of tests for \texttt{find\_empty\_rows}:

\begin{lstlisting}
library(tidyverse)
library(testthat)
context("Finding empty rows")

source("../../scripts/find_empty_02.R")

test_that("A single non-empty row is not mistakenly detected", {
  result <- find_empty_rows("a\n1")
  expect_equal(result, NULL)
})

test_that("Half-empty rows are not mistakenly detected", {
  result <- find_empty_rows("a,b\n,2")
  expect_equal(result, NULL)
})

test_that("An empty row in the middle is found", {
  result <- find_empty_rows("a,b\n1,2\n,\n5,6")
  expect_equal(result, c(2L))
})
\end{lstlisting}

\noindent
And here's what happens when we run this file with \texttt{test\_dir}:

\begin{lstlisting}
test_dir("tests/testthat", "find_empty_a")
\end{lstlisting}

\begin{lstlisting}
v |  OK F W S | Context

/ |   0       | Finding empty rows
x |   1 2     | Finding empty rows
---------------------------------------------------------------------------
test_find_empty_a.R:9: failure: A single non-empty row is not mistakenly detected
`result` not equal to NULL.
Types not compatible: integer is not NULL

test_find_empty_a.R:14: failure: Half-empty rows are not mistakenly detected
`result` not equal to NULL.
Types not compatible: integer is not NULL
---------------------------------------------------------------------------

== Results ================================================================
OK:       1
Failed:   2
Warnings: 0
Skipped:  0
\end{lstlisting}

This is perplexing:
we expected that if there were no empty rows,
our function would return \texttt{NULL}.
Let's look more closely:

\begin{lstlisting}
source("scripts/find_empty_02.R")
find_empty_rows("a\n1")
\end{lstlisting}

\begin{lstlisting}
integer(0)
\end{lstlisting}

\noindent
Ah:
our function is returning an integer vector of zero length rather than \texttt{NULL}.
Let's have a closer look at the properties of this strange beast:

\begin{lstlisting}
print(glue("integer(0) equal to NULL? {is.null(integer(0))}"))
\end{lstlisting}

\begin{lstlisting}
integer(0) equal to NULL? FALSE
\end{lstlisting}

\begin{lstlisting}
print(glue("any(logical(0))? {any(logical(0))}"))
\end{lstlisting}

\begin{lstlisting}
any(logical(0))? FALSE
\end{lstlisting}

\begin{lstlisting}
print(glue("all(logical(0))? {all(logical(0))}"))
\end{lstlisting}

\begin{lstlisting}
all(logical(0))? TRUE
\end{lstlisting}

All right.
If we compare \texttt{c(1L, 2L)} to \texttt{NULL}, we expect \texttt{c(FALSE, FALSE)},
so it's reasonable to get a zero-length logical vector as a result
when we compare \texttt{NULL} to an integer vector with no elements.
The fact that \texttt{any} of an empty logical vector is \texttt{FALSE}
isn't really surprising either---none of the elements are \texttt{TRUE},
so it would be hard to say that any of them are.
\texttt{all} of an empty vector being \texttt{TRUE} is unexpected, though.
The reasoning is apparently that none of the (nonexistent) elements are \texttt{FALSE},
but honestly,
at this point we are veering dangerously close to \href{https://www.destroyallsoftware.com/talks/wat}{JavaScript Logic},
so we will accept this result for what it is and move on.

So what \emph{should} our function return when there aren't any empty rows: \texttt{NULL} or \texttt{integer(0)}?
After a bit of thought,
we decide on the latter,
which means it's the tests that we need to rewrite,
not the code:

\begin{lstlisting}
library(tidyverse)
library(testthat)
context("Finding empty rows")

source("../../scripts/find_empty_02.R")

test_that("A single non-empty row is not mistakenly detected", {
  result <- find_empty_rows("a\n1")
  expect_equal(result, integer(0))
})

test_that("Half-empty rows are not mistakenly detected", {
  result <- find_empty_rows("a,b\n,2")
  expect_equal(result, integer(0))
})

test_that("An empty row in the middle is found", {
  result <- find_empty_rows("a,b\n1,2\n,\n5,6")
  expect_equal(result, c(2L))
})
\end{lstlisting}

And here's what happens when we run this file with \texttt{test\_dir}:

\begin{lstlisting}
test_dir("tests/testthat", "find_empty_b")
\end{lstlisting}

\begin{lstlisting}
v |  OK F W S | Context

/ |   0       | Finding empty rows
v |   3       | Finding empty rows

== Results ================================================================
OK:       3
Failed:   0
Warnings: 0
Skipped:  0
\end{lstlisting}

\section{How can we check data transformation?}

People normally write unit tests for the code in packages,
not to check the steps taken to clean up particular datasets,
but the latter are just as useful as the former.
To illustrate,
we have been given several more CSV files to clean up.
The first,
\texttt{at\_health\_facilities.csv},
shows the percentage of births at health facilities by country, year, and mother's age.
It comes from the same UNICEF website as our previous data,
but has a different set of problems.
Here are its first few lines:

\begin{lstlisting}
,,GLOBAL DATABASES,,,,,,,,,,,,,
,,[data.unicef.org],,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Indicator:,Delivered in health facilities,,,,,,,,,,,,,,
Unit:,Percentage,,,,,,,,,,,,,,
,,,,Mother's age,,,,,,,,,,,
iso3,Country/areas,year,Total ,age 15-17,age 18-19,age less than 20,age more than 20,age 20-34,age 35-49,Source,Source year,,,,
AFG,Afghanistan,2010,   33 ,    25 ,    29 ,    28 ,    31 ,    31 ,    31 ,MICS,2010,,,,
ALB,Albania,2005,   98 ,    100 ,   96 ,    97 ,    98 ,    99 ,    92 ,MICS,2005,,,,
ALB,Albania,2008,   98 ,    94 ,    98 ,    97 ,    98 ,    98 ,    99 ,DHS,2008,,,,
...
\end{lstlisting}

and its last:

\begin{lstlisting}
ZWE,Zimbabwe,2005,  66 ,    64 ,    64 ,    64 ,    67 ,    69 ,    53 ,DHS,2005,,,,
ZWE,Zimbabwe,2009,  58 ,    49 ,    59 ,    55 ,    59 ,    60 ,    52 ,MICS,2009,,,,
ZWE,Zimbabwe,2010,  64 ,    56 ,    66 ,    62 ,    64 ,    65 ,    60 ,DHS,2010,,,,
ZWE,Zimbabwe,2014,  80 ,    82 ,    82 ,    82 ,    79 ,    80 ,    77 ,MICS,2014,,,,
,,,,,,,,,,,,,,,
Definition:,Percentage of births delivered in a health facility.,,,,,,,,,,,,,,
,"The indicator refers to women who had a live birth in a recent time period, generally two years for MICS and five years for DHS.",,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Note:,"Database include reanalyzed data from DHS and MICS, using a reference period of two years before the survey.",,,,,,,,,,,,,,
,Includes surveys which microdata were available as of April 2016. ,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Source:,"UNICEF global databases 2016 based on DHS, MICS .",,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Contact us:,data@unicef.org,,,,,,,,,,,,,,
\end{lstlisting}

There are two other files in this collection called \texttt{c\_sections.csv} and \texttt{skilled\_attendant\_at\_birth.csv},
which are the number of Caesarean sections
and the number of births where a midwife or other trained practitioner was present.
All three datasets have been exported from the same Excel spreadsheet;
rather than writing a separate script for each,
we should create a tool that will handle them all.

At first glance,
the problems we need to solve to do this are:

\begin{enumerate}
\item
  Each file may have a different number of header rows
  (by inspection, two of the files have 7 and one has 8),
  so we should infer this number from the file.
\item
  Each file may contain a different number of records,
  so our tool should select rows by content rather than by absolute row number.
\item
  The files appear to have the same column names
  (for which we give thanks),
  but we should check this in case someone tries to use our function
  with a dataset that doesn't.
\end{enumerate}

\noindent
These three requirements will make our program significantly more complicated,
so we should tackle each with its own testable function.

\subsection*{How can we reorganize code to make it more testable?}

The data we care about comes
after the row with \texttt{iso3}, \texttt{Country/areas}, and other column headers,
so the simplest way to figure out how many rows to skip is to read the data,
look for this row,
and discard everything above it.
The simplest way to do \emph{that} is to read the file once to find the number of header rows,
then read it again,
discarding that number of rows.
It's inefficient,
but for a dataset this size,
simplicity beats performance.

Here's our first try:

\begin{lstlisting}
read_csv("data/at_health_facilities.csv") %>%
  select(check = 1) %>%
  mutate(id = row_number()) %>%
  filter(check == "iso3") %>%
  select(id) %>%
  first()
\end{lstlisting}

\begin{lstlisting}
Warning: Missing column names filled in: 'X1' [1], 'X2' [2], 'X4' [4],
'X5' [5], 'X6' [6], 'X7' [7], 'X8' [8], 'X9' [9], 'X10' [10], 'X11' [11],
'X12' [12], 'X13' [13], 'X14' [14], 'X15' [15], 'X16' [16]
\end{lstlisting}

\begin{lstlisting}
Parsed with column specification:
cols(
  X1 = col_character(),
  X2 = col_character(),
  `GLOBAL DATABASES` = col_character(),
  X4 = col_character(),
  X5 = col_character(),
  X6 = col_character(),
  X7 = col_character(),
  X8 = col_character(),
  X9 = col_character(),
  X10 = col_character(),
  X11 = col_character(),
  X12 = col_character(),
  X13 = col_logical(),
  X14 = col_logical(),
  X15 = col_logical(),
  X16 = col_logical()
)
\end{lstlisting}

\begin{lstlisting}
[1] 7
\end{lstlisting}

\noindent
Ignoring the messages about missing column names,
this tells us that \texttt{iso3} appears in row 7 of our data,
which is \emph{almost} true:
it's actually in row 8,
because \texttt{read\_csv} has interpreted the first row of the raw CSV data as a header.
On the bright side,
that means we can immediately use this value as the \texttt{skip} parameter to the next \texttt{read\_csv} call.

How do we test this code?
Easy:
we turn it into a function,
tell that function to stop if it can't find \texttt{iso3} in the data,
and write some unit tests.
The function is:

\begin{lstlisting}
determine_skip_rows <- function(src_path) {
  read_csv(src_path) %>%
    select(check = 1) %>%
    mutate(id = row_number()) %>%
    filter(check == "iso3") %>%
    select(id) %>%
    first()
}
\end{lstlisting}

We can then call \texttt{usethis::use\_testthat()} to set up some testing infrastructure,
including the directory \texttt{tests/testthat}
and a script called \texttt{tests/testthat.R}
that will run all our tests when we want to check the integrity of our project.
Once we have done that
we can put these five tests in \texttt{tests/testthat/test\_determine\_skip\_rows.R}:

\begin{lstlisting}
library(tidyverse)
library(testthat)
context("Skipping rows correctly")

source("../../scripts/determine_skip_rows_a.R")

test_that("The right row is found when there are header rows", {
  result <- determine_skip_rows("a1,a2\nb1,b2\nis03,stuff\nc1,c2\n")
  expect_equal(result, 2)
})

test_that("The right row is found when there are header rows and blank lines", {
  result <- determine_skip_rows("a1,a2\nb1,b2\n,\nis03,stuff\nc1,c2\n,\n")
  expect_equal(result, 3)
})

test_that("The right row is found when there are no header rows to discard", {
  result <- determine_skip_rows("iso3,stuff\nc1,c2\n")
  expect_equal(result, 0)
})

test_that("No row is found when 'iso3' isn't present", {
  expect_error(determine_skip_rows("a1,a2\nb1,b1\n"),
               "No start row found")
})

test_that("No row is found when 'iso3' is in the wrong place", {
  expect_error(determine_skip_rows("stuff,iso3\n"),
               "No start row found")
})
\end{lstlisting}

\noindent
and run it:

\begin{lstlisting}
test_dir("tests/testthat", "determine_skip_rows_a")
\end{lstlisting}

\begin{lstlisting}
v |  OK F W S | Context

/ |   0       | Skipping rows correctly
x |   0 5     | Skipping rows correctly
---------------------------------------------------------------------------
test_determine_skip_rows_a.R:9: failure: The right row is found when there are header rows
`result` not equal to 2.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:14: failure: The right row is found when there are header rows and blank lines
`result` not equal to 3.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:19: failure: The right row is found when there are no header rows to discard
`result` not equal to 0.
Lengths differ: 0 is not 1

test_determine_skip_rows_a.R:23: failure: No row is found when 'iso3' isn't present
`determine_skip_rows("a1,a2\nb1,b1\n")` did not throw an error.

test_determine_skip_rows_a.R:28: failure: No row is found when 'iso3' is in the wrong place
`determine_skip_rows("stuff,iso3\n")` did not throw an error.
---------------------------------------------------------------------------

== Results ================================================================
OK:       0
Failed:   5
Warnings: 0
Skipped:  0

Don't worry, you'll get it.
\end{lstlisting}

That's right: all five fail.
The first problem is that we have written \texttt{is03}
(with a digit \texttt{0} instead of a letter \texttt{o})
in the first two tests.
If we fix that and re-run the tests, they pass;
what about the other three?

\begin{enumerate}
\item
  When there are no rows to skip, our function returns \texttt{integer(0)} instead of 0
  because the row with \texttt{iso3} is being used as headers.
\item
  When \texttt{iso3} isn't found at all, the function is returning \texttt{integer(0)} rather than stopping.
\end{enumerate}

\noindent
Here is a more robust version of the function:

\begin{lstlisting}
determine_skip_rows <- function(src_path) {
  data <- read_csv(src_path)
  if (names(data)[1] == "iso3") {
    return(0)
  }
  result <- data %>%
    select(check = 1) %>%
    mutate(id = row_number()) %>%
    filter(check == "iso3") %>%
    select(id) %>%
    first()
  if (length(result) == 0) {
    stop("No start row found in", src_path)
  }
  result
}
\end{lstlisting}

\noindent
And here are the results:

\begin{lstlisting}
test_dir("tests/testthat", "determine_skip_rows_b")
\end{lstlisting}

\begin{lstlisting}
v |  OK F W S | Context

/ |   0       | Skipping rows correctly
v |   5       | Skipping rows correctly

== Results ================================================================
OK:       5
Failed:   0
Warnings: 0
Skipped:  0
\end{lstlisting}

Our tests still don't check anything statistical,
but without trustworthy data our statistics will be meaningless.
Tests like these allow our future selves to focus on making new mistakes
instead of repeating old ones.

\begin{quote}
\textbf{Is unit testing the right approach for data science?}

I know how to test e-commerce websites or database drivers:
define some input values and their corresponding outputs,
then write functions to run the code on the former
and check that it produces the latter.
I now believe this methodology is wrongheaded for many data scientists:
it's often impossible to know what to expect without actually doing the analysis,
and once we have an answer we often need to move on to the next analysis.
But this is not the same as saying ``don't test'':

\begin{enumerate}
\item
  Most data scientists do a lot of testing:
  they just do it interactively and incrementally as they're doing their analysis,
  usually by viewing results as they add one stage after another
  to their analysis pipeline.
  This works,
  but doesn't leave any traces to show the next person
  what testing was done
  or why it convinced the author that the analysis was correct.

\item
  Some analyses are one-of-a-kind,
  but many are repeated for different datasets.
  Those \emph{could} be tested using the classic software approach,
  but the code is usually built up as described in the previous point,
  and if it's hard to know what answers to expect before doing the first few analyses,
  it's doubly hard to invent examples where the code will run without error
  but produce a wrong answer.
\end{enumerate}

As of the time of writing,
my provisional conclusion is that
people writing packages for others to use should write unit tests,
if only to be explicit about what their packages will and will not accept as valid input.
My other conclusion is that we need to build tools that support
the interactive and incremental workflow most data analysts use,
but what those might look like is beyond the scope of this book.
\end{quote}

\section{Key Points}

\begin{itemize}
\item
  Operations signal conditions in R when errors occur.
\item
  The three built-in levels of conditions are messages, warnings, and errors.
\item
  Programs can signal these themselves using the functions \texttt{message}, \texttt{warning}, and \texttt{stop}.
\item
  Operations can be placed in a call to the function \texttt{try} to suppress errors, but this is a bad idea.
\item
  Operations can be placed in a call to the function \texttt{tryCatch} to handle errors.
\item
  Use testthat to write unit tests for R.
\item
  Put unit tests for an R package in the \texttt{tests/testthat} directory.
\item
  Put tests in files called test\_group.R and call them test\_something.
\item
  Use \texttt{test\_dir} to run tests from a particular that match a pattern.
\item
  Write tests for data transformation steps as well as library functions.
\end{itemize}

\section{Exercises}

\begin{enumerate}

\item
  Section~\ref{testerror-organize} gave the function \texttt{expect\_equal} two arguments
  called \texttt{tolerance} and \texttt{scale}.
  \begin{enumerate}
    \item
      How is \texttt{tolerance} used if we set \texttt{scale} to 1?
    \item
      How is \texttt{tolerance} used if we set \texttt{scale} to some positive value?
    \item
      What happens if we set \texttt{scale} to zero or a negative value?
    \item
      Suppose you are writing a function to calculate the mean of a million numbers,
      each of which is between 0 and 1 inclusive.
      What tolerance and scale would you use to check your result?
      How does this compare to the tolerance and scale other people would use?
    \item
      What tolerances were used in testing the statistical libraries your work relies on?
  \end{enumerate}

\item
  \label{rectangle-overlap}
  A colleague of yours has written a function that takes two rectangles as input
  and finds their overlap (which it returns as another rectangle).
  Each rectangle is represented as a vector of four values $(x_{low}, y_{low}, x_{high}, y_{high})$,
  so after:

\begin{lstlisting}
first <- c(0.0, 0.0, 2.0, 2.0)
second <- c(1.0, 1.0, 3.0, 3.0)
result <- rectangleOverlap(first, second)
\end{lstlisting}

  \noindent
  the variable \texttt{result} contains \texttt{c(1, 1, 2, 2)}.
  \begin{enumerate}
  \item
    Write the function \texttt{rectangleOverlap}.
  \item
    Write six tests for it using \texttt{testthat}.
  \item
    After you are done testing, turn to Appendix~\ref{testquestions}
    and compare your implementation with ours.
  \end{enumerate}

\end{enumerate}
